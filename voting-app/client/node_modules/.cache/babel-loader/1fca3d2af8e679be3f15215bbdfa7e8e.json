{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\n\nconst bigInt = require('big-integer');\n\nbigInt.rand = function (bitLength) {\n  let bytes = bitLength / 8;\n  let buf = Buffer.alloc(bytes);\n  crypto.randomFillSync(buf);\n  buf[0] = buf[0] | 128; // first bit to 1 -> to get the necessary bitLength\n\n  return bigInt.fromArray([...buf], 256);\n};\n\nbigInt.randBetween = function (start, end) {\n  // crypto rand in [start, end]\n  let interval = end.subtract(start);\n  let arr = interval.toArray(256).value;\n  let buf = Buffer.alloc(arr.length);\n  let bn;\n\n  do {\n    crypto.randomFillSync(buf);\n    bn = bigInt.fromArray([...buf], 256).add(start);\n  } while (bn.compare(end) >= 0 || bn.compare(start) < 0);\n\n  return bn;\n};\n\nbigInt.prime = function (bitLength) {\n  let rnd;\n\n  do {\n    rnd = bigInt.rand(bitLength);\n    console.assert(rnd.bitLength() == bitLength, 'ERROR: ' + rnd.bitLength() + ' != ' + bitLength);\n  } while (!rnd.isPrime());\n\n  return bigInt(rnd);\n};\n\nbigInt.prototype.bitLength = function () {\n  let bits = 1;\n  let result = this;\n  const two = bigInt(2);\n\n  while (result.greater(bigInt.one)) {\n    result = result.divide(two);\n    bits++;\n  }\n\n  return bits;\n};\n\nconst generateRandomKeys = function (bitLength = 2048, simplevariant = false) {\n  let p, q, n, phi, n2, g, lambda, mu; // if p and q are bitLength/2 long ->  2**(bitLength - 2) <= n < 2**(bitLenght) \n\n  do {\n    p = bigInt.prime(bitLength / 2);\n    q = bigInt.prime(bitLength / 2);\n    n = p.multiply(q);\n  } while (q.compare(p) == 0 || n.bitLength() != bitLength);\n\n  phi = p.subtract(1).multiply(q.subtract(1));\n  n2 = n.pow(2);\n\n  if (simplevariant === true) {\n    //If using p,q of equivalent length, a simpler variant of the key\n    // generation steps would be to set\n    // g=n+1, lambda=(p-1)(q-1), mu=lambda.modInv(n)\n    g = n.add(1);\n    lambda = phi;\n    mu = lambda.modInv(n);\n  } else {\n    g = getGenerator(n, n2);\n    lambda = bigInt.lcm(p.subtract(1), q.subtract(1));\n    mu = L(g.modPow(lambda, n2), n).modInv(n);\n  }\n\n  const publicKey = new PaillierPublicKey(n, g);\n  const privateKey = new PaillierPrivateKey(lambda, mu, p, q, publicKey);\n  return {\n    publicKey: publicKey,\n    privateKey: privateKey\n  };\n};\n\nconst PaillierPublicKey = class PaillierPublicKey {\n  constructor(n, g) {\n    this.n = bigInt(n);\n    this._n2 = n.pow(2); // cache n^2\n\n    this.g = bigInt(g);\n  }\n\n  get bitLength() {\n    return this.n.bitLength();\n  }\n\n  encrypt(m) {\n    let r;\n\n    do {\n      r = bigInt.randBetween(2, this.n);\n    } while (r.leq(1));\n\n    return this.g.modPow(bigInt(m), this._n2).multiply(r.modPow(this.n, this._n2)).mod(this._n2);\n  }\n\n  addition(...ciphertexts) {\n    return ciphertexts.reduce((sum, next) => sum.multiply(bigInt(next)).mod(this._n2), bigInt(1));\n  }\n\n  multiply(c, k) {\n    // c is ciphertext. k is a number\n    return bigInt(c).modPow(k, this._n2);\n  }\n\n};\nconst PaillierPrivateKey = class PaillierPrivateKey {\n  constructor(lambda, mu, p, q, publicKey) {\n    this.lambda = bigInt(lambda);\n    this.mu = bigInt(mu);\n    this._p = bigInt(p);\n    this._q = bigInt(q);\n    this.publicKey = publicKey;\n  }\n\n  get bitLength() {\n    return this.publicKey.n.bitLength();\n  }\n\n  get n() {\n    return this.publicKey.n;\n  }\n\n  decrypt(c) {\n    return L(bigInt(c).modPow(this.lambda, this.publicKey._n2), this.publicKey.n).multiply(this.mu).mod(this.publicKey.n);\n  }\n\n};\n\nfunction L(a, n) {\n  return a.subtract(1).divide(n);\n}\n\nfunction getGenerator(n, n2 = n.pow(2)) {\n  const alpha = bigInt.randBetween(2, n);\n  const beta = bigInt.randBetween(2, n);\n  return alpha.multiply(n).add(1).multiply(beta.modPow(n, n2)).mod(n2);\n}\n\nmodule.exports = {\n  generateRandomKeys: generateRandomKeys,\n  PrivateKey: PaillierPrivateKey,\n  PublicKey: PaillierPublicKey\n};","map":null,"metadata":{},"sourceType":"script"}