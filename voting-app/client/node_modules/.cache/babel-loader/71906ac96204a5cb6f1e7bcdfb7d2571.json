{"ast":null,"code":"var _slicedToArray = require(\"/home/tomas/Voting app (2)/voting-app/client/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nconst paillier = require('paillier-js');\n\nconst bigInt = require('big-integer');\n\nconst crypto = require('crypto'); // rEncrypt :: Paillier.PublicKey -> Message\n// Fork from paillier-js - Create Paillier Encryption of message and return the random Paillier.R with the result\n\n\nconst rEncrypt = function ({\n  n,\n  g\n}, message) {\n  const _n2 = n.pow(2);\n\n  let r;\n\n  do {\n    r = bigInt.randBetween(2, n);\n  } while (r.leq(1));\n\n  return [r, g.modPow(bigInt(message), _n2).multiply(r.modPow(n, _n2)).mod(_n2)];\n}; // getCoprime :: Bits -> Number -> Number\n// Generate a coprime number of target (their GCD should be 1)\n\n\nconst getCoprime = target => {\n  const bits = Math.floor(Math.log2(target));\n\n  while (true) {\n    const lowerBound = bigInt(2).pow(bits - 1).plus(1);\n    const size = bigInt(2).pow(bits).subtract(lowerBound);\n    let possible = lowerBound.plus(bigInt.rand(bits)).or(1);\n    const result = bigInt(possible);\n    if (possible.gt(bigInt(2).pow(1024))) return result;\n\n    while (target > 0) {\n      var _ref = [target, possible.mod(target)];\n      possible = _ref[0];\n      target = _ref[1];\n    }\n\n    if (possible.eq(bigInt(1))) return result;\n  }\n}; // encryptWithProof :: Paillier.PublickKey -> Message -> [Message] -> Bits\n// Generate a message encryption and a Zero Knowledge proof that the message \n// is among a set of valid messages\n\n\nconst encryptWithProof = (publicKey, message, validMessages, bits = 512) => {\n  const as = [];\n  const es = [];\n  const zs = [];\n\n  const _rEncrypt = rEncrypt(publicKey, message),\n        _rEncrypt2 = _slicedToArray(_rEncrypt, 2),\n        random = _rEncrypt2[0],\n        cipher = _rEncrypt2[1];\n\n  const om = getCoprime(publicKey.n);\n  const ap = om.modPow(publicKey.n, publicKey._n2);\n  let mi = null;\n  validMessages.forEach((mk, i) => {\n    const gmk = publicKey.g.modPow(bigInt(mk), publicKey._n2);\n    const uk = cipher.times(gmk.modInv(publicKey._n2)).mod(publicKey._n2);\n\n    if (message === mk) {\n      as.push(ap);\n      zs.push(null);\n      es.push(null);\n      mi = i;\n    } else {\n      const zk = getCoprime(publicKey.n);\n      zs.push(zk);\n      const ek = bigInt.randBetween(2, bigInt(2).pow(bits).subtract(1));\n      es.push(ek);\n      const zn = zk.modPow(publicKey.n, publicKey._n2);\n      const ue = uk.modPow(ek, publicKey._n2);\n      const ak = zn.times(ue.modInv(publicKey._n2)).mod(publicKey._n2);\n      as.push(ak);\n    }\n  });\n  const hash = crypto.createHash('sha256').update(as.join('')).digest('hex');\n  const esum = es.filter(Boolean).reduce((acc, ek) => acc.plus(ek).mod(bigInt(2).pow(256)), bigInt(0));\n  const ep = bigInt(hash, 16).subtract(esum).mod(bigInt(2).pow(256));\n  const rep = random.modPow(ep, publicKey.n);\n  const zp = om.times(rep).mod(publicKey.n);\n  es[mi] = ep;\n  zs[mi] = zp;\n  const proof = [as, es, zs];\n  return [cipher, proof, random];\n}; // verifyProof :: Paillier.PublickKEy -> Paillier.Encryption, -> Proof -> [Message] -> Bool\n// Verify a Zero Knowledge proof that an encrypted message is among a set of valid messages\n\n\nconst verifyProof = (publicKey, cipher, [as, es, zs], validMessages) => {\n  const hash = crypto.createHash('sha256').update(as.join('')).digest('hex');\n  const us = validMessages.map(mk => {\n    const gmk = publicKey.g.modPow(mk, publicKey._n2);\n    const uk = cipher.times(gmk.modInv(publicKey._n2)).mod(publicKey._n2);\n    return uk;\n  });\n  const esum = es.reduce((acc, ek) => acc.plus(ek).mod(bigInt(2).pow(256)), bigInt(0));\n\n  if (!bigInt(hash, 16).eq(esum)) {\n    return false;\n  }\n\n  return zs.every((zk, i) => {\n    const ak = as[i];\n    const ek = es[i];\n    const uk = us[i];\n    const zkn = zk.modPow(publicKey.n, publicKey._n2);\n    const uke = uk.modPow(ek, publicKey._n2);\n    const akue = ak.times(uke).mod(publicKey._n2);\n    return zkn.eq(akue);\n  });\n};\n\nconst leftPad = (str, length) => [...Array(Math.max(0, length - str.length))].map(_ => '0').join('') + str;\n\nconst toNumber = (str, bits = 16) => bigInt(str.split('').map(char => char.charCodeAt(0)).filter(code => !isNaN(code) && code > 0 && code < 2 ** bits).map(code => leftPad(code.toString(2), bits)).reduce((acc, code) => acc + code, ''), 2);\n\nmodule.exports = {\n  encryptWithProof,\n  verifyProof\n};","map":null,"metadata":{},"sourceType":"script"}